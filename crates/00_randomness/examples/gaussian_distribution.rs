use macroquad::prelude::*;
use rand_distr::{Distribution, Normal};

#[macroquad::main("Gaussian Distribution")]
async fn main() {
    // create RNG explicitly from the external rand crate
    let mut rng = ::rand::thread_rng();
    let normal = Normal::new(0.0, 50.0).unwrap();

    const TRANSPARENT_RED: Color = Color {
        r: 1.0,
        g: 0.0,
        b: 0.0,
        a: 0.02,
    };

    let x = screen_width() / 2.;
    let y = screen_height() / 2.;
    let r = 5.;

    let render_target = render_target(screen_width() as u32, screen_height() as u32);
    render_target.texture.set_filter(FilterMode::Nearest);

    let camera = Camera2D {
        zoom: vec2(2.0 / screen_width(), -2.0 / screen_height()),
        target: vec2(screen_width() / 2.0, screen_height() / 2.0),
        render_target: Some(render_target.clone()),
        ..Default::default()
    };

    set_camera(&camera);
    clear_background(BLACK);

    loop {
        set_camera(&camera);
        let sample = normal.sample(&mut rng);

        // .sample() takes the uniform random number generated by rng and then converts them into
        // the normally distributed random number using algorithms such as box-mullers transform or
        // ziggorat algo

        draw_circle(x + sample, y, r, TRANSPARENT_RED);
        // draw_circle_lines(x + sample, y, r, 0.5, BLACK); // would make a good loading screen or
        // something ( very trippy)

        set_default_camera();
        clear_background(BLACK);
        draw_texture_ex(
            &render_target.texture,
            0.0,
            0.0,
            WHITE,
            DrawTextureParams {
                dest_size: Some(vec2(screen_width(), screen_height())),
                flip_y: true,
                ..Default::default()
            },
        );

        next_frame().await;
    }
}
